[üìçProblem Link](https://practice.geeksforgeeks.org/problems/maximize-number-of-1s0905/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=maximize-number-of-1s)

**Sample Test Case**
```
Example 1:

Input:
N = 3
arr[] = {1, 0, 1}
M = 1
Output:
3
Explanation:
Maximum subarray is of size 3
which can be made subarray of all 1 after
flipping one zero to 1.
Example 2:

Input:
N = 11
arr[] = {1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1}
M = 2
Output:
8
Explanation:
Maximum subarray is of size 8
which can be made subarray of all 1 after
flipping two zeros to 1.
```

## First Approach : Use a nested loop to iterate over all possible subarrays of the given binary array, and for each subarray, count the number of zeros and ones in it

```java
class Solve {

    int findZeroes(int arr[], int n, int m) {
        int maxLen = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int zeros = 0, ones = 0;
            for (int k = i; k <= j; k++) {
                if (arr[k] == 0) {
                    zeros++;
                } else {
                    ones++;
                }
            }
            if (zeros <= m) {
                maxLen = Math.max(maxLen, ones + zeros);
            }
        }
    }
    return maxLen;
    }
}
```

This approach has a time complexity of O(N^3), since we are using two nested loops to iterate over all possible subarrays, <br>
and an additional loop to count the number of zeros and ones in each subarray.

After submission 31/510 test cases passed, need more optimization.
